# Gitlet Design Document

**Name**:

## Classes and Data Structures

### Main
程序入口点。从命令行接受参数，根据命令参数调用不同的函数。
调用的函数来自Repository类。

#### Fields
无


### Repository
中介。负责相应main的调用并调用其他的各种类各种方法。
负责程序主要逻辑。


#### Fields

1. static final File CWD，程序当前工作目录。
2. static final File GITLET_FOLDER，存储gitlet状态的目录。
3. static final File BLOBS_FOLDER，存储blobs的目录。
4. static final File STAGING_FOLDER，添加暂存目录。
5. static final File 
6. static final File COMMIT_FOLDER，存储commit信息的目录。

### Commit

commit类包括：date、msg与当前版本文件列表与**blob对应的哈希值**，如“a.txt->asfihcwniekdim”。

使用ADT的map表示存储的文件，为了方便查找使用BST（暂定）。除了BST之外其他的删除太麻烦，BST最坏也就是个链表。
如果真有机会想攀登高峰的话建议一步到位红黑树。虽然是个tree，但是实现的是map哒！

每次工作（add等等）都会新建一个working_commit，操作会改变这个commit的内容。提交之后，commit被写入**再也不能改啦**的文件，文件名也改成相应的哈希值。

不存在指针，不会保存除了这次commit之外的冗余信息。

#### Fields

1.

## Algorithms
数据结构编不出来了，我先编算法

### init
在当前目录中创建一个新的 Gitlet 版本控制系统。
此系统将自动启动一个提交：一个不包含任何文件且提交信息为 initial commit 的提交。
它将有一个分支： master ，它最初指向这个初始提交，而 master 将是当前分支。
此初始提交的时间戳为“The (Unix) Epoch”。

 - Runtime：O(1)

创建固定内容的commit。确实runtime是常数，不需要特别的算法。

1. 创建相应的文件夹结构
2. 创建固定内容的commit类，没有文件内容
3. 剩下的交给commit操作


### add
将当前存在的文件副本添加到暂存区。

1. 暂存区有了：覆盖旧条目。
2. 文件版本与提交版本一模一样：不加；暂存区有了（不同版本的）：移除
3. 之前删除过：删了还在目录里存在只有两种可能：(1) 之前add过但是取消了；(2) 没跟踪过。所以加就对了。
   1. 想得美。
   2. 之前删除过，不在目录里，但是在删除暂存区里：这个文件曾经被跟踪，但是删过一次，于是它就从跟踪目录与真的CWD中消失了，出现在了删除区里——那就把人家从删除暂存区里挪出来。
   3. 挪出来之后呢？恢复到目录里吗？没写就是不。恢复跟踪吗？没写就是不。
   
 - Runtime：O(N): N=文件大小；O(lg N): N=文件数量

1. add逻辑交给Repository类实现，具体操作看情况交给哪位勇士
2. 在CWD中搜索要add的文件（二分查找？）
3. 根据具体情况处理文件，比较文件是否一致就用哈希值罢……
4. 先看当前提交的版本是否一致（通过head指针指向的commit类判断，commit类会（以BST的方式）存储文件列表
5. 暂存区的不用看，要么删了要么覆盖。
6. 最后看一眼删除区有没有
7. failure case在最开始进行判断。



### commit
保存当前提交和暂存区中被跟踪文件的快照，创建一个新提交。 
提交将保存并开始跟踪任何已暂存以供添加但未被其父提交跟踪的文件。
最后，当前提交中被跟踪的文件可能会在新提交中被取消跟踪，这可能是由于通过 rm 命令暂存以供删除所导致的。

- 提交后，暂存区会被清空。
- 在暂存以供添加或删除后对文件所做的任何更改都将被提交命令忽略，提交命令只会修改 .gitlet 目录的内容。例如，如果您使用 Unix 的 rm 命令（而不是 Gitlet 的同名命令）删除一个被跟踪的文件，这对下一个提交没有影响，下一个提交仍将包含该文件的（现在已删除的）版本。
- 刚刚创建的提交成为“当前提交”，头指针现在指向它。之前的头提交是该提交的父提交。
- 每个提交通过其 SHA-1 id 进行标识，该 id 必须包括其文件的 blob 引用、父引用、日志消息和提交时间。
- Runtime：O(1)，N=提交数量；O(N)，N=跟踪的文件总大小。

1. 首先检查当前CWD下的文件，检查rm暂存区确定要跟踪的文件列表
2. 检查add暂存区，把更新的文件指向新的blob，其余指向父节点的blob
3. 把commit存储到相应文件夹
4. 把commit的ref存储起来，更新commit树(head)


### rm
1. add了：取消add。
2. 跟踪了：标记为删除，顺便把真文件也删了。
3. 没跟踪：不删。

- Runtime: O(1)

---删-除-应-该-用-不-到-暂-存-区-。---

想得美，需要。

在情况2的时候，把真文件删了，同时在删除区里存一下。

### log
沿着提交树直到初始提交，遵循第一个父提交链接，忽略在合并提交中发现的任何第二个父提交。

对于合并提交（具有两个父提交的提交），在第一个提交下方添加一行。

- Runtime: O(N)，N=历史中的节点数量。

### global-log
显示所有曾经做过的提交的信息。提交的顺序无关紧要。

- Runtime: O(N)，N=commit数量

目前为止最简单的一位，遍历commit文件夹就ok
……如果不需要显示merge的父节点的话。我先按照不需要理解，需要再改。

### find
打印出所有具有给定提交信息的提交 ID，每行一个。
如果有多个这样的提交，它会在不同的行上打印出这些 ID。

- Runtime: O(N)，N=提交数量。

### status
显示当前存在的分支。

未暂存的修改和未跟踪的文件是额外加分项。

条目应按字典顺序列出，使用 Java 字符串比较顺序（星号不计入）。

- Runtime: 仅依赖于工作目录中的数据量，加上待添加或删除的文件数量，加上分支的数量。

### checkout
把不同版本的文件checkout出来。CWD中有的就覆盖，覆盖后的新版本不暂存。

如果check的是个分支，那就把文件改成相应的分支（不能是目前的分支，即使做了修改）的样子，head也要指向那个分支。
就完全变成这个分支的样子，增加的文件，删了！暂存的东西，删了！
但是如果有未跟踪的文件，就报错退出。

对id少于40个字符的commit来说，应当实现哈希前六位寻址。

- Runtime：
  - O(N), N=被检出的文件的大小。
  - O(N), N=提交快照中所有文件的总大小
  - O(1), N=涉及提交数量的任何度量与分支数量。


### branch
创建一个具有给定名称的新分支，并将其指向当前的头提交。
此命令不会立即切换到新创建的分支。
在调用branch之前，您的代码应该在一个名为“master”的默认分支上运行。

- Runtime: O(1)

### rm-branch
删除具有给定名称的分支。
仅意味着删除与该分支关联的指针；并不意味着删除在该分支下创建的所有提交或其他任何内容。
不删除当前分支。

- Runtime: O(1)

这要怎么O(1)，分支多起来判断是否有这个分支不会慢起来吗。怎么着也得lgN啊。
要把分支名称也变成哈希吗……不至于吧真的。


### reset
**reuse your code :)**

检出由给定提交跟踪的所有文件。
该命令本质上是对任意提交的检出，同时也更改当前分支的头指针。


### merge
将当前分支与给定分支合并。做出的修改自动暂存，然后自动提交，提交时标记为合并。

如果分裂点与给定分支是同一个提交：不做任何操作。

如果分裂点是当前分支：检出给定分支

在给定分支中被修改但在当前分支中未被修改的文件：
更改为给定分支中的版本（从给定分支前面的提交中检出）。这些文件应自动暂存。

在当前分支中被修改但在给定分支中自分裂点以来未被修改的任何文件：保持不变。

在当前分支和给定分支中以相同方式被修改的任何文件（即，两个文件现在具有相同内容或都被删除）：保持不变。
如果一个文件在当前分支和给定分支中都被删除，但在工作目录中存在同名文件，则该文件保持不变，并在合并中继续缺失（不被跟踪也不被暂存）。

在分裂点不存在且仅在当前分支中存在的文件：持不变。

在分裂点不存在且仅在给定分支中存在的文件：检出并暂存。

在分裂点存在、在当前分支中未被修改且在给定分支中缺失的文件：删除且不被跟踪。

在分裂点存在、在给定分支中未被修改且在当前分支中缺失的文件：保持缺失。

在当前分支和给定分支中以不同方式被修改的任何文件存在冲突：替换文件内容
“以不同方式被修改”可以意味着两个文件的内容都被更改且不同，或者一个文件的内容被更改而另一个文件被删除，或者文件在分裂点缺失且在给定分支和当前分支中具有不同内容。

一旦根据上述内容更新了文件，并且分裂点不是当前分支或给定分支，合并将自动提交，日志消息为“已合并 [给定分支名称] 到 [当前分支名称]”。然后，如果合并遇到冲突，终端（而不是日志）将打印消息“遇到合并冲突”。

- Runtime: O(NlgN+D)，N=两个分支的祖先提交的总数，D=这些提交下所有文件的数据总量。


## Persistence

拟使用的文件结构。

```
CWD                             <==== current working directory
└── .gitlet                     <==== All persistant data is stored within here
    ├── head                    <==== name of branch
    └── branch                  <==== hokano branches
        ├── master              <==== ref of commit
        ├── ...
        └── branchN
    └── staging                 <==== staging area
        ├── add_list            <==== files need to be tracked or modified
        ├── rm_list             <==== have been tracked, but removed! now!
        └── add
            ├── file1
            ├── file2
            ├── ...
            └── fileN
    └── commit                  <==== All commits are stored in this directory
        ├── commit1             <==== A commit file, whose name will be its hash code
        ├── commit2
        ├── ...
        └── commitN
    └── blob                    <==== All blobs are stored in this directory
        ├── blob1               <==== blob file, whose name will be its hash code
        ├── blob2
        ├── ...
        └── blobN
```

---
考虑一下该死的持久性的问题。

如何确定一个文件是否被追踪？
——曾经被add到暂存区的都追踪。追踪的文件列表会存储在每个commit类里。当前工作更改的情况会由暂存区存储，提交的时候commit会整合add与rm暂存区的信息更新跟踪的文件列表，以及文件名指向的blob。

暂存区里到底应该存什么？
——对add：单开一个文件夹存储文件blob。add列表、rm列表由一个文件存储。

对于指针相连的提交树，存一个就存一大片，怎么办？
——不存储指针，父节点也是一个ref。

log怎么办？
——不怎么办，merge还是要显示俩父节点的ref的。老老实实ref寻址吧。

global-log怎么办？
——这可太好办了。

ref寻址太慢了？
——1. ……像git一样，先比较前俩字母，但是utils好像不给我这个机会；2. 反正utils的辅助方法会返回字母序文件，二分查找！

head指针如何寻址？
——head文件中存储相应的ref值

哈希值什么时候计算？
——提交的时候，暂存区里的文件使用正常的文件名称

---
持久性的设置：交给repository类，建立所有的文件夹


